<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Org Chart (Virtualized Canvas)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    #canvasWrap { touch-action: none; }
    .kbd { border: 1px solid #CBD5E1; border-bottom-width: 3px; padding: 0 .35rem; border-radius: .375rem; }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Controls -->
  <header class="sticky top-0 z-10 bg-white/80 backdrop-blur border-b border-slate-200">
    <div class="max-w-7xl mx-auto px-4 py-3 flex flex-wrap items-center gap-3">
      <h1 class="text-lg font-semibold">Org Chart (Canvas, Virtualized)</h1>
      <div class="grow"></div>

      <label class="flex items-center gap-2 text-sm">
        Node W
        <input id="nodeW" type="range" min="140" max="360" value="220" class="accent-slate-800">
      </label>
      <label class="flex items-center gap-2 text-sm">
        H Gap
        <input id="hGap" type="range" min="24" max="160" value="48" class="accent-slate-800">
      </label>
      <label class="flex items-center gap-2 text-sm">
        V Gap
        <input id="vGap" type="range" min="48" max="200" value="96" class="accent-slate-800">
      </label>
      <label class="flex items-center gap-2 text-sm">
        Max depth to render
        <input id="maxDepth" type="number" step="1" min="1" value="2" class="w-16 border rounded px-2 py-1">
      </label>

      <button id="fitBtn" class="px-3 py-1.5 rounded-xl bg-slate-900 text-white text-sm hover:bg-slate-800">Fit root</button>
      <button id="expandAllBtn" class="px-3 py-1.5 rounded-xl bg-slate-100 text-slate-900 text-sm border hover:bg-slate-200">Expand all</button>
      <button id="collapseAllBtn" class="px-3 py-1.5 rounded-xl bg-slate-100 text-slate-900 text-sm border hover:bg-slate-200">Collapse all</button>
    </div>
  </header>

  <!-- Data panel -->
  <section class="max-w-7xl mx-auto px-4 py-4 grid grid-cols-1 lg:grid-cols-2 gap-4">
    <div class="bg-white rounded-2xl shadow p-4 border border-slate-200">
      <div class="flex items-center gap-3 mb-2">
        <h2 class="font-semibold">Data</h2>
        <div class="grow"></div>
        <input id="fileInput" type="file" accept="application/json" class="text-sm">
        <button id="loadBtn" class="px-3 py-1.5 rounded-xl bg-slate-900 text-white text-sm hover:bg-slate-800">Load</button>
        <button id="sampleBtn" class="px-3 py-1.5 rounded-xl bg-slate-100 text-slate-900 text-sm border hover:bg-slate-200">Sample</button>
      </div>
      <textarea id="jsonInput" class="w-full h-48 font-mono text-xs p-3 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-slate-300" placeholder='[{"id":"ceo","displayName":"CEO","jobTitle":"Chief Executive Officer","department":"Exec","managerId":null,"reports":["vp1","vp2"]}, ...]'></textarea>
      <div class="flex flex-wrap items-center gap-3 mt-2">
        <input id="rootId" type="text" placeholder="Optional: root id to focus" class="border rounded px-2 py-1 text-sm">
        <button id="renderBtn" class="px-3 py-1.5 rounded-xl bg-indigo-600 text-white text-sm hover:bg-indigo-500">Render</button>
        <div class="text-xs text-slate-500">Tip: hold <span class="kbd">Space</span> to pan, scroll to zoom. Click a node to toggle it.</div>
      </div>
    </div>

    <div class="bg-white rounded-2xl shadow p-4 border border-slate-200">
      <h2 class="font-semibold mb-2">Search</h2>
      <div class="flex items-center gap-2">
        <input id="searchBox" type="text" placeholder="Name / title / id" class="flex-1 border rounded px-3 py-2 text-sm">
        <button id="searchBtn" class="px-3 py-1.5 rounded-xl bg-slate-100 text-slate-900 text-sm border hover:bg-slate-200">Find</button>
      </div>
      <div id="searchInfo" class="text-xs text-slate-500 mt-2"></div>
    </div>
  </section>

  <!-- Canvas -->
  <section class="px-2 pb-6">
    <div id="canvasWrap" class="bg-white border border-slate-200 rounded-2xl shadow mx-auto max-w-7xl h-[70vh] overflow-hidden relative">
      <canvas id="chart" class="absolute inset-0"></canvas>
    </div>
  </section>

  <script>
    // =============== Worker (layout off main thread) ===============
    const layoutWorkerSrc = `
      let data = null;
      function normalize(raw){
        const byId = new Map();
        for (const r of raw||[]){
          const id = String(r.id ?? ''); if(!id) continue;
          const name = r.displayName || r.mailNickname || r.userPrincipalName || r.mail || id;
          const title = (typeof r.jobTitle==='string' && r.jobTitle.includes('|')) ? r.jobTitle.split('|')[0] : (r.jobTitle||'');
          byId.set(id, { id, name, title, department: r.department||null, managerId: (r.managerId!=null?r.managerId:null), _reports: Array.isArray(r.reports)?r.reports:[], collapsed:false });
        }
        // infer manager from reports if missing
        for(const n of byId.values()){
          for(const rep of n._reports){
            const cid = typeof rep==='string' ? rep : (rep && rep.id ? String(rep.id) : null);
            if(!cid) continue;
            const child = byId.get(cid);
            if(child && (child.managerId==null || child.managerId==='')) child.managerId = n.id;
          }
        }
        return [...byId.values()];
      }
      function buildForest(nodes){
        const byId = new Map(nodes.map(n => [String(n.id), {...n, id:String(n.id)}]));
        const children = new Map([...byId.keys()].map(k => [k, []]));
        const hasParent = new Set();
        for(const n of byId.values()){
          if(n.managerId!=null && byId.has(String(n.managerId))){
            const pid = String(n.managerId);
            children.get(pid).push(n.id);
            hasParent.add(n.id);
          }
        }
        const roots = [...byId.keys()].filter(k=>!hasParent.has(k));
        // sort children by label for stability
        for(const [k,arr] of children) arr.sort((a,b)=>{
          const A = (byId.get(a)?.name||'').toLowerCase();
          const B = (byId.get(b)?.name||'').toLowerCase();
          return A.localeCompare(B);
        });
        return {byId, children, roots};
      }
      // layout using slot-based centering; returns coords, depth, subtree slots
      function layoutForest(forest, opts){
        const { byId, children, roots } = forest;
        const nodeW=opts.nodeW, nodeH=opts.nodeH, hGap=opts.hGap, vGap=opts.vGap, depthLimit=opts.depthLimit|0;

        const subtreeSlots = new Map();
        function slots(id, depth){
          const node = byId.get(id); if(!node) {subtreeSlots.set(id,1); return 1;}
          if(node.collapsed) {subtreeSlots.set(id,1); return 1;}
          if(depthLimit && depth>=depthLimit) {subtreeSlots.set(id,1); return 1;}
          const ch = children.get(id)||[];
          if(!ch.length) {subtreeSlots.set(id,1); return 1;}
          let sum=0; for(const c of ch) sum += slots(c, depth+1);
          subtreeSlots.set(id, Math.max(1,sum)); return subtreeSlots.get(id);
        }

        const coords = new Map();
        function place(id, xOffset, depth){
          const node = byId.get(id); if(!node) return 0;
          const ch = (children.get(id)||[]);
          const visible = node.collapsed || (depthLimit && depth>=depthLimit) ? [] : ch;
          const s = subtreeSlots.get(id) || 1;
          const cx = xOffset + (s-1)/2;
          const x = cx * (nodeW + hGap);
          const y = depth * (nodeH + vGap);
          coords.set(id, [x,y]);
          let childOffset=xOffset;
          for(const c of visible){
            const cs = subtreeSlots.get(c)||1;
            place(c, childOffset, depth+1);
            childOffset += cs;
          }
          return s;
        }

        let xCursor=0; let maxDepth=0;
        const rootsList = roots.length?roots:[...byId.keys()].slice(0,1);
        for(const r of rootsList){
          slots(r,0);
          const s = subtreeSlots.get(r)||1;
          place(r, xCursor, 0);
          xCursor += s;
        }
        for(const [_,xy] of coords){ const y = xy[1]; const d = Math.round(y/(nodeH+vGap)); if(d>maxDepth) maxDepth=d; }
        const totalSlots=xCursor||1;
        const width  = totalSlots*(nodeW+hGap)-hGap;
        const height = (maxDepth+1)*(nodeH+vGap)-vGap;
        return { coords: [...coords.entries()], width, height };
      }

      function filterSubtree(forest, rootId){
        if(!rootId || !forest.byId.has(String(rootId))) return forest;
        const id = String(rootId);
        const byId = new Map(); const children = new Map(); const roots=[id];
        function collect(x){
          const n = forest.byId.get(x); if(!n) return;
          byId.set(x, n);
          const ch = forest.children.get(x)||[];
          children.set(x, ch.filter(c=>forest.byId.has(c)));
          for(const c of ch) collect(c);
        }
        collect(id);
        return {byId, children, roots};
      }

      onmessage = (e)=>{
        const { type, payload } = e.data;
        if(type==='layout'){
          try{
            const { raw, opts, rootId } = payload;
            const nodes = normalize(raw);
            const forest = buildForest(nodes);
            const focus = filterSubtree(forest, rootId);
            const out = layoutForest(focus, opts);
            // compress byId map for quick lookup (id -> [name,title,dept,collapsed,managerId])
            const compact = {};
            for(const [id,n] of focus.byId.entries()){
              compact[id] = [n.name||'', n.title||'', n.department||'', !!n.collapsed, n.managerId==null?null:String(n.managerId)];
            }
            postMessage({ ok:true, coords: out.coords, width: out.width, height: out.height, meta: compact, children: [...focus.children.entries()] });
          }catch(err){
            postMessage({ ok:false, error: String(err && err.message || err) });
          }
        }else if(type==='toggle'){
          try{
            const { id, raw, opts, rootId } = payload;
            const nodes = normalize(raw);
            const forest = buildForest(nodes);
            const n = forest.byId.get(String(id)); if(n){ n.collapsed = !n.collapsed; }
            const focus = filterSubtree(forest, rootId);
            const out = layoutForest(focus, opts);
            const compact = {};
            for(const [id2,n2] of focus.byId.entries()){
              compact[id2] = [n2.name||'', n2.title||'', n2.department||'', !!n2.collapsed, n2.managerId==null?null:String(n2.managerId)];
            }
            postMessage({ ok:true, coords: out.coords, width: out.width, height: out.height, meta: compact, children: [...focus.children.entries()] });
          }catch(err){
            postMessage({ ok:false, error: String(err && err.message || err) });
          }
        }
      };
    `;
    const worker = new Worker(URL.createObjectURL(new Blob([layoutWorkerSrc], {type:'text/javascript'})));

    // =============== App state ===============
    const canvas = document.getElementById('chart');
    const wrap = document.getElementById('canvasWrap');
    const ctx = canvas.getContext('2d');

    let RAW = [];           // original data array (flat)
    let META = {};          // id -> [name,title,dept,collapsed,managerId]
    let CHILDREN = [];      // [id, [childId,...]]
    let COORDS = [];        // [[id,[x,y]], ...] in layout space
    let LAYOUT_W = 0, LAYOUT_H = 0;

    // visual params
    const state = {
      nodeW: 220, nodeH: 80, hGap: 48, vGap: 96,
      depthLimit: 2,               // initial depth limit
      scale: 1, offsetX: 20, offsetY: 20,   // view transform
      rootId: null,
    };

    // =============== Helpers ===============
    function dprResize() {
      const dpr = window.devicePixelRatio || 1;
      const w = wrap.clientWidth, h = wrap.clientHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function toScreen(x, y) {
      return [ (x*state.scale + state.offsetX), (y*state.scale + state.offsetY) ];
    }
    function toLayout(sx, sy) {
      return [ (sx - state.offsetX)/state.scale, (sy - state.offsetY)/state.scale ];
    }

    function requestLayout(toggleId=null){
      const opts = {
        nodeW: state.nodeW,
        nodeH: state.nodeH,
        hGap: state.hGap,
        vGap: state.vGap,
        depthLimit: state.depthLimit
      };
      if(toggleId){
        worker.postMessage({ type:'toggle', payload: { id: toggleId, raw: RAW, opts, rootId: state.rootId } });
      }else{
        worker.postMessage({ type:'layout', payload: { raw: RAW, opts, rootId: state.rootId } });
      }
    }

    worker.onmessage = (e)=>{
      const { ok, error, coords, width, height, meta, children } = e.data || {};
      if(!ok){ alert('Layout error: ' + error); return; }
      COORDS = coords || [];
      META = meta || {};
      CHILDREN = children || [];
      LAYOUT_W = width || 0;
      LAYOUT_H = height || 0;
      draw();
    };

    // =============== Drawing (virtualized) ===============
    function draw(){
      dprResize();
      ctx.save();

      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // clip to canvas
      ctx.beginPath();
      ctx.rect(0,0,canvas.clientWidth, canvas.clientHeight);
      ctx.clip();

      // compute visible layout rect
      const [lx0, ly0] = toLayout(0,0);
      const [lx1, ly1] = toLayout(canvas.clientWidth, canvas.clientHeight);
      const visPad = 200; // extra pad to avoid popping on pan
      const minX = lx0 - visPad, maxX = lx1 + visPad;
      const minY = ly0 - visPad, maxY = ly1 + visPad;

      const nodeW = state.nodeW, nodeH = state.nodeH;

      // quick map for children lookups
      const childMap = new Map(CHILDREN);

      // ----- edges -----
      ctx.strokeStyle = '#CBD5E1'; // slate-300
      ctx.lineWidth = 1.25;
      for(const [pid, kids] of childMap){
        const metaP = META[pid]; if(!metaP) continue;
        // if parent is collapsed, skip edges
        if(metaP[3]) continue;
        const pxy = getCoord(pid); if(!pxy) continue;
        const px = pxy[0] + nodeW/2, py = pxy[1] + nodeH;
        for(const cid of kids){
          const cxy = getCoord(cid); if(!cxy) continue;
          // culling by bbox of edge
          const ex0 = Math.min(px, cxy[0] + nodeW/2), ex1 = Math.max(px, cxy[0] + nodeW/2);
          const ey0 = Math.min(py, cxy[1]), ey1 = Math.max(py, cxy[1]);
          if(ex1 < minX || ex0 > maxX || ey1 < minY || ey0 > maxY) continue;

          const midY = (py + cxy[1]) / 2;
          const [sx, sy] = toScreen(px, py);
          const [mx1, my1] = toScreen(px, midY);
          const [mx2, my2] = toScreen(cxy[0] + nodeW/2, midY);
          const [tx, ty] = toScreen(cxy[0] + nodeW/2, cxy[1]);

          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.bezierCurveTo(mx1, my1, mx2, my2, tx, ty);
          ctx.stroke();
        }
      }

      // ----- nodes -----
      for(const [id, xy] of COORDS){
        const x = xy[0], y = xy[1];
        if(x > maxX || (x+nodeW) < minX || y > maxY || (y+nodeH) < minY) continue;

        const [sx, sy] = toScreen(x, y);
        drawNode(id, sx, sy, nodeW*state.scale, nodeH*state.scale);
      }

      ctx.restore();
    }

    function getCoord(id){
      // COORDS is array; a Map would be faster; build a cache:
      if(!getCoord.cache) getCoord.cache = new Map();
      if(getCoord.cache.has(id)) return getCoord.cache.get(id);
      for(const [k, v] of COORDS){ if(k===id){ getCoord.cache.set(id, v); return v; } }
      return null;
    }

    function drawNode(id, sx, sy, w, h){
      // card
      roundedRect(ctx, sx, sy, w, h, 12);
      ctx.fillStyle = '#FFFFFF';
      ctx.strokeStyle = '#94A3B8'; // slate-400
      ctx.lineWidth = 1;
      ctx.fill();
      ctx.stroke();

      const meta = META[id] || ['', '', '', false, null];
      const name = meta[0], title = meta[1], dept = meta[2], collapsed = meta[3];
      // name
      ctx.fillStyle = '#0F172A'; // slate-900
      ctx.font = `${Math.max(12*state.scale,10)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textBaseline = 'top';
      const padX = 10*state.scale, padY = 10*state.scale;
      textTrunc(ctx, name, sx + padX, sy + padY, w - 2*padX);

      // title
      ctx.fillStyle = '#64748B'; // slate-500
      ctx.font = `${Math.max(11*state.scale,9)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      textTrunc(ctx, title, sx + padX, sy + padY + 18*state.scale, w - 2*padX);

      // dept badge
      if(dept){
        const badge = String(dept);
        const bw = Math.min(measureText(ctx, badge) + 12*state.scale, w - 2*padX);
        const bh = 18*state.scale;
        const bx = sx + padX, by = sy + h - bh - 8*state.scale;
        roundedRect(ctx, bx, by, bw, bh, 9*state.scale);
        ctx.fillStyle = '#F8FAFC'; ctx.fill();
        ctx.strokeStyle = '#E2E8F0'; ctx.stroke();
        ctx.fillStyle = '#334155';
        ctx.font = `${Math.max(10*state.scale,8)}px system-ui`;
        ctx.textBaseline = 'middle';
        ctx.fillText(badge, bx + 6*state.scale, by + bh/2);
      }

      // toggle indicator
      const kids = (new Map(CHILDREN)).get(id) || [];
      if(kids.length){
        const r = 10*state.scale;
        const cx = sx + w - r - 6*state.scale, cy = sy + r + 6*state.scale;
        roundedRect(ctx, cx-r, cy-r, 2*r, 2*r, r);
        ctx.fillStyle = collapsed ? '#F1F5F9' : '#EEF2FF';
        ctx.strokeStyle = collapsed ? '#CBD5E1' : '#C7D2FE';
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = collapsed ? '#334155' : '#3730A3';
        ctx.font = `${Math.max(11*state.scale,9)}px system-ui`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(collapsed?'+':'−', cx, cy + (navigator.platform.includes('Win')?1:0));
      }
    }

    function roundedRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }
    function measureText(ctx, s){
      const m = ctx.measureText(String(s)); return (m.actualBoundingBoxLeft || 0) + (m.actualBoundingBoxRight || 0) + m.width || m.width;
    }
    function textTrunc(ctx, text, x, y, maxW){
      const s = String(text||'');
      if(ctx.measureText(s).width <= maxW){ ctx.fillText(s, x, y); return; }
      let lo=0, hi=s.length, mid;
      while(lo<hi){
        mid = ((lo+hi+1)>>1);
        if(ctx.measureText(s.slice(0,mid)+'…').width <= maxW) lo=mid; else hi=mid-1;
      }
      ctx.fillText(s.slice(0,lo)+'…', x, y);
    }

    // =============== Interaction: pan/zoom + picking ===============
    let isPanning=false, lastX=0, lastY=0, spaceDown=false;

    wrap.addEventListener('mousedown', (e)=>{
      if(spaceDown || e.button===1){ isPanning=true; lastX=e.clientX; lastY=e.clientY; e.preventDefault(); }
    });
    window.addEventListener('mouseup', ()=> isPanning=false);
    window.addEventListener('mousemove', (e)=>{
      if(!isPanning) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;
      state.offsetX += dx; state.offsetY += dy;
      draw();
    });
    window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ spaceDown=true; e.preventDefault(); }});
    window.addEventListener('keyup',   (e)=>{ if(e.code==='Space'){ spaceDown=false; }});

    wrap.addEventListener('wheel', (e)=>{
      const delta = -Math.sign(e.deltaY) * 0.1;
      const oldScale = state.scale;
      state.scale = Math.min(2.5, Math.max(0.25, state.scale * (1 + delta)));
      // zoom about cursor position
      const rect = wrap.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      const [lx, ly] = toLayout(cx, cy);
      state.offsetX = cx - lx*state.scale;
      state.offsetY = cy - ly*state.scale;
      e.preventDefault();
      draw();
    }, { passive:false });

    // toggle node by click
    wrap.addEventListener('click', (e)=>{
      // ignore if we were panning
      if(isPanning) return;
      const rect = wrap.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      const [lx, ly] = toLayout(x, y);
      // hit test nodes
      const w = state.nodeW, h = state.nodeH;
      for(const [id, xy] of COORDS){
        const nx = xy[0], ny = xy[1];
        if(lx>=nx && lx<=nx+w && ly>=ny && ly<=ny+h){
          // toggle in worker
          requestLayout(id);
          getCoord.cache = null;
          return;
        }
      }
    });

    // =============== UI wiring ===============
    const nodeW = document.getElementById('nodeW');
    const hGap  = document.getElementById('hGap');
    const vGap  = document.getElementById('vGap');
    const maxDepth = document.getElementById('maxDepth');
    const fitBtn = document.getElementById('fitBtn');
    const expandAllBtn = document.getElementById('expandAllBtn');
    const collapseAllBtn = document.getElementById('collapseAllBtn');

    nodeW.addEventListener('input', ()=>{ state.nodeW = parseInt(nodeW.value,10)||220; requestLayout(); getCoord.cache=null; });
    hGap.addEventListener('input',  ()=>{ state.hGap  = parseInt(hGap.value,10)||48;   requestLayout(); getCoord.cache=null; });
    vGap.addEventListener('input',  ()=>{ state.vGap  = parseInt(vGap.value,10)||96;   requestLayout(); getCoord.cache=null; });
    maxDepth.addEventListener('change', ()=>{ state.depthLimit = Math.max(1, parseInt(maxDepth.value,10)||2); requestLayout(); getCoord.cache=null; });

    fitBtn.addEventListener('click', ()=>{
      // Fit top-left root area
      state.offsetX = 20; state.offsetY = 20; state.scale = 1;
      draw();
    });

    expandAllBtn.addEventListener('click', ()=>{
      // Reset RAW collapsed flags to false and re-layout
      RAW.forEach(r=>{ r.collapsed=false; });
      requestLayout();
      getCoord.cache=null;
    });
    collapseAllBtn.addEventListener('click', ()=>{
      RAW.forEach(r=>{ r.collapsed=true; });
      requestLayout();
      getCoord.cache=null;
    });

    // Data load/render
    const fileInput = document.getElementById('fileInput');
    const loadBtn = document.getElementById('loadBtn');
    const renderBtn = document.getElementById('renderBtn');
    const sampleBtn = document.getElementById('sampleBtn');
    const jsonInput = document.getElementById('jsonInput');
    const rootId = document.getElementById('rootId');

    loadBtn.addEventListener('click', async ()=>{
      const f = fileInput.files?.[0]; if(!f){ alert('Pick a JSON file'); return; }
      const text = await f.text();
      jsonInput.value = text;
      renderBtn.click();
    });

    renderBtn.addEventListener('click', ()=>{
      try{
        RAW = JSON.parse(jsonInput.value);
        RAW.forEach(r=>{ r.collapsed=false; }); // default open
        state.rootId = (rootId.value||'').trim() || null;
        requestLayout();
        getCoord.cache=null;
      }catch(e){ alert('Invalid JSON: ' + e.message); }
    });

    sampleBtn.addEventListener('click', ()=>{
      const sample = [];
      // small synthetic tree for quick test
      sample.push({id:'ceo', displayName:'CEO', jobTitle:'Chief Executive Officer', department:'Exec', managerId:null, reports:['vp1','vp2','vp3']});
      for(let i=1;i<=3;i++){
        const vp = `vp${i}`;
        sample.push({id:vp, displayName:`VP ${i}`, jobTitle:'Vice President', department:'Dept '+i, managerId:'ceo', reports:[`m${i}a`,`m${i}b`,`m${i}c`]});
        ['a','b','c'].forEach((s,idx)=>{
          const mid = `m${i}${s}`;
          sample.push({id:mid, displayName:`Mgr ${i}${s.toUpperCase()}`, jobTitle:'Manager', department:'Ops', managerId:vp, reports:[`ic${i}${s}1`,`ic${i}${s}2`,`ic${i}${s}3`,`ic${i}${s}4`]});
          for(let k=1;k<=4;k++){
            sample.push({id:`ic${i}${s}${k}`, displayName:`IC ${i}${s}${k}`, jobTitle:'Engineer', department:'IMSD', managerId:mid});
          }
        });
      }
      jsonInput.value = JSON.stringify(sample, null, 2);
      rootId.value = '';
      renderBtn.click();
    });

    // Search
    const searchBox = document.getElementById('searchBox');
    const searchBtn = document.getElementById('searchBtn');
    const searchInfo = document.getElementById('searchInfo');

    searchBtn.addEventListener('click', ()=>{
      const q = (searchBox.value||'').toLowerCase().trim();
      if(!q){ searchInfo.textContent=''; return; }
      // linear scan over META (ok for manual search; for heavy use, build an index)
      let bestId=null, bestScore=-1;
      for(const [id, m] of Object.entries(META)){
        const name=(m[0]||'').toLowerCase(), title=(m[1]||'').toLowerCase();
        let score = 0;
        if(name.includes(q)) score+=2;
        if(title.includes(q)) score+=1;
        if(id.toLowerCase().includes(q)) score+=1;
        if(score>bestScore){ bestScore=score; bestId=id; }
      }
      if(!bestId){ searchInfo.textContent='No match.'; return; }
      // center on node
      const xy = getCoord(bestId); if(!xy){ searchInfo.textContent='Found, but not laid out.'; return; }
      const [x,y] = xy;
      const centerX = wrap.clientWidth/2, centerY = wrap.clientHeight/2;
      state.offsetX = centerX - (x + state.nodeW/2)*state.scale;
      state.offsetY = centerY - (y + state.nodeH/2)*state.scale;
      searchInfo.textContent = `Centered: ${META[bestId][0]} (${bestId})`;
      draw();
    });

    // Initial canvas size
    dprResize();

    // Optional: auto-load users_flat.json if present (uncomment to try)
    // fetch('users_flat.json').then(r=>r.ok?r.text():Promise.reject()).then(t=>{ jsonInput.value=t; renderBtn.click(); }).catch(()=>{});
  </script>
</body>
</html>
