<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Server tips:
       Content-Type: text/html; charset=utf-8
       X-Content-Type-Options: nosniff
       (optional for hashed assets) Cache-Control: public, max-age=31536000, immutable
  -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Org Chart (Canvas, Virtualized, Editable)</title>

  <!-- Tailwind CDN (ok to keep) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    /* Compatibility: WebKit prefix first */
    html { -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }
    html, body { height: 100%; }
    #canvasWrap { touch-action: none; }
    .kbd { border: 1px solid #CBD5E1; border-bottom-width: 3px; padding: 0 .35rem; border-radius: .375rem; }

    /* Cross-browser hide scrollbars */
    @supports (scrollbar-width: none) { .no-scrollbar { scrollbar-width: none; } }
    .no-scrollbar { -ms-overflow-style: none; }
    .no-scrollbar::-webkit-scrollbar { display: none; }

    /* a11y */
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Header / Controls -->
  <header class="sticky top-0 z-10 bg-white/80 backdrop-blur border-b border-slate-200" role="banner">
    <div class="max-w-7xl mx-auto px-4 py-3 flex flex-wrap items-center gap-3">
      <h1 class="text-lg font-semibold">Org Chart (Canvas, Virtualized, Editable)</h1>
      <div class="grow"></div>

      <div class="flex items-center gap-4" role="group" aria-label="Layout controls">
        <div class="flex items-center gap-2">
          <label for="nodeW" class="text-sm">Node width</label>
          <input id="nodeW" type="range" min="140" max="360" value="220" class="accent-slate-800"
                 aria-valuemin="140" aria-valuemax="360" aria-valuenow="220" />
        </div>
        <div class="flex items-center gap-2">
          <label for="hGap" class="text-sm">H gap</label>
          <input id="hGap" type="range" min="24" max="160" value="48" class="accent-slate-800"
                 aria-valuemin="24" aria-valuemax="160" aria-valuenow="48" />
        </div>
        <div class="flex items-center gap-2">
          <label for="vGap" class="text-sm">V gap</label>
          <input id="vGap" type="range" min="48" max="200" value="96" class="accent-slate-800"
                 aria-valuemin="48" aria-valuemax="200" aria-valuenow="96" />
        </div>
        <div class="flex items-center gap-2">
          <label for="maxDepth" class="text-sm">Max depth</label>
          <input id="maxDepth" type="number" step="1" min="1" value="3"
                 class="w-16 border rounded px-2 py-1" inputmode="numeric" />
        </div>

        <button id="fitBtn" class="px-3 py-1.5 rounded-xl bg-slate-900 text-white text-sm hover:bg-slate-800" type="button">Fit</button>
        <button id="expandAllBtn" class="px-3 py-1.5 rounded-xl bg-slate-100 text-slate-900 text-sm border hover:bg-slate-200" type="button">Expand all</button>
        <button id="collapseAllBtn" class="px-3 py-1.5 rounded-xl bg-slate-100 text-slate-900 text-sm border hover:bg-slate-200" type="button">Collapse all</button>

        <div class="h-6 w-px bg-slate-200 mx-1" aria-hidden="true"></div>

        <label class="flex items-center gap-2 text-sm">
          <input id="editMode" type="checkbox" class="w-4 h-4">
          Edit mode
        </label>
        <button id="undoBtn" class="px-3 py-1.5 rounded-xl bg-slate-100 text-slate-900 text-sm border hover:bg-slate-200" type="button" disabled>Undo</button>
        <button id="downloadBtn" class="px-3 py-1.5 rounded-xl bg-indigo-600 text-white text-sm hover:bg-indigo-500" type="button">Download JSON</button>
      </div>
    </div>
  </header>

  <!-- Data + Search -->
  <main class="max-w-7xl mx-auto px-4 py-4 grid grid-cols-1 lg:grid-cols-2 gap-4" role="main">
    <!-- Data panel -->
    <section class="bg-white rounded-2xl shadow p-4 border border-slate-200" aria-labelledby="dataSectionHeading">
      <div class="flex items-center gap-3 mb-2">
        <h2 id="dataSectionHeading" class="font-semibold">Data</h2>
        <div class="grow"></div>
        <div class="flex items-center gap-2">
          <label for="fileInput" class="sr-only">Load JSON file</label>
          <input id="fileInput" type="file" accept="application/json" class="text-sm" />
          <button id="loadBtn" class="px-3 py-1.5 rounded-xl bg-slate-900 text-white text-sm hover:bg-slate-800" type="button">Load</button>
          <button id="sampleBtn" class="px-3 py-1.5 rounded-xl bg-slate-100 text-slate-900 text-sm border hover:bg-slate-200" type="button">Sample</button>
        </div>
      </div>

      <p class="text-xs text-slate-500 mb-2">
        Schema: <code>{ id, displayName, jobTitle, department, managerId, reports? }</code>.
        Manager is inferred from <code>reports</code> when present.
      </p>

      <div class="mb-2">
        <label for="jsonInput" class="sr-only">Paste JSON</label>
        <textarea id="jsonInput"
                  class="w-full h-48 font-mono text-xs p-3 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-slate-300"
                  placeholder='[{"id":"ceo","displayName":"CEO","jobTitle":"Chief Executive Officer","department":"Exec","managerId":null,"reports":["vp1","vp2"]}]'
                  aria-label="Paste JSON data"></textarea>
      </div>

      <div class="flex flex-wrap items-center gap-3 mt-2">
        <div class="flex items-center gap-2">
          <label for="rootId" class="text-sm">Root ID</label>
          <input id="rootId" type="text" class="border rounded px-2 py-1 text-sm"
                 placeholder="Optional: focus subtree by id" />
        </div>
        <button id="renderBtn" class="px-3 py-1.5 rounded-xl bg-indigo-600 text-white text-sm hover:bg-indigo-500" type="button">Render</button>
        <p class="text-xs text-slate-500 m-0">
          Tip: hold <span class="kbd" aria-label="Space key">Space</span> to pan, scroll to zoom. Click a node to toggle. Drag in <em>Edit mode</em> to reassign manager.
        </p>
      </div>
    </section>

    <!-- Search panel -->
    <section class="bg-white rounded-2xl shadow p-4 border border-slate-200" aria-labelledby="searchSectionHeading">
      <h2 id="searchSectionHeading" class="font-semibold mb-2">Search</h2>
      <div class="flex items-center gap-2">
        <label for="searchBox" class="sr-only">Search text</label>
        <input id="searchBox" type="text" class="flex-1 border rounded px-3 py-2 text-sm"
               placeholder="Name / title / id" aria-label="Search by name, title, or id" />
        <button id="searchBtn" class="px-3 py-1.5 rounded-xl bg-slate-100 text-slate-900 text-sm border hover:bg-slate-200" type="button">Find</button>
      </div>
      <div id="searchInfo" class="text-xs text-slate-500 mt-2" role="status" aria-live="polite"></div>
    </section>
  </main>

  <!-- Canvas -->
  <section class="px-2 pb-6" aria-label="Org chart">
    <div id="canvasWrap" class="bg-white border border-slate-200 rounded-2xl shadow mx-auto max-w-7xl h-[70vh] overflow-hidden relative no-scrollbar">
      <canvas id="chart" class="absolute inset-0" role="img" aria-label="Organization chart visualization"></canvas>
      <!-- live overlays for drag feedback -->
      <div id="overlay" class="pointer-events-none absolute inset-0"></div>
    </div>
  </section>

  <script>
    // ================== Worker (layout off main thread) ==================
    const layoutWorkerSrc = `
      function normalize(raw){
        const byId = new Map();
        for (const r of raw||[]){
          const id = String(r.id ?? ''); if(!id) continue;
          const name = r.displayName || r.mailNickname || r.userPrincipalName || r.mail || id;
          const title = (typeof r.jobTitle==='string' && r.jobTitle.includes('|')) ? r.jobTitle.split('|')[0] : (r.jobTitle||'');
          byId.set(id, { id, name, title, department: r.department||null, managerId: (r.managerId!=null?r.managerId:null), _reports: Array.isArray(r.reports)?r.reports:[], collapsed: !!r.collapsed });
        }
        // infer manager from reports if missing
        for(const n of byId.values()){
          for(const rep of n._reports){
            const cid = typeof rep==='string' ? rep : (rep && rep.id ? String(rep.id) : null);
            if(!cid) continue;
            const child = byId.get(cid);
            if(child && (child.managerId==null || child.managerId==='')) child.managerId = n.id;
          }
        }
        return [...byId.values()];
      }
      function buildForest(nodes){
        const byId = new Map(nodes.map(n => [String(n.id), {...n, id:String(n.id)}]));
        const children = new Map([...byId.keys()].map(k => [k, []]));
        const hasParent = new Set();
        for(const n of byId.values()){
          if(n.managerId!=null && byId.has(String(n.managerId))){
            const pid = String(n.managerId);
            children.get(pid).push(n.id);
            hasParent.add(n.id);
          }
        }
        const roots = [...byId.keys()].filter(k=>!hasParent.has(k));
        // sort children for stable layout
        for(const [k,arr] of children) arr.sort((a,b)=>{
          const A = (byId.get(a)?.name||'').toLowerCase();
          const B = (byId.get(b)?.name||'').toLowerCase();
          return A.localeCompare(B);
        });
        return {byId, children, roots};
      }
      function layoutForest(forest, opts){
        const { byId, children, roots } = forest;
        const nodeW=opts.nodeW, nodeH=opts.nodeH, hGap=opts.hGap, vGap=opts.vGap, depthLimit=opts.depthLimit|0;

        const subtreeSlots = new Map();
        function slots(id, depth){
          const node = byId.get(id); if(!node) {subtreeSlots.set(id,1); return 1;}
          if(node.collapsed) {subtreeSlots.set(id,1); return 1;}
          if(depthLimit && depth>=depthLimit) {subtreeSlots.set(id,1); return 1;}
          const ch = children.get(id)||[];
          if(!ch.length) {subtreeSlots.set(id,1); return 1;}
          let sum=0; for(const c of ch) sum += slots(c, depth+1);
          subtreeSlots.set(id, Math.max(1,sum)); return subtreeSlots.get(id);
        }

        const coords = new Map();
        function place(id, xOffset, depth){
          const node = byId.get(id); if(!node) return 0;
          const ch = (children.get(id)||[]);
          const visible = node.collapsed || (depthLimit && depth>=depthLimit) ? [] : ch;
          const s = subtreeSlots.get(id) || 1;
          const cx = xOffset + (s-1)/2;
          const x = cx * (nodeW + hGap);
          const y = depth * (nodeH + vGap);
          coords.set(id, [x,y]);
          let childOffset=xOffset;
          for(const c of visible){
            const cs = subtreeSlots.get(c)||1;
            place(c, childOffset, depth+1);
            childOffset += cs;
          }
          return s;
        }

        let xCursor=0; let maxDepth=0;
        const rootsList = roots.length?roots:[...byId.keys()].slice(0,1);
        for(const r of rootsList){
          slots(r,0);
          const s = subtreeSlots.get(r)||1;
          place(r, xCursor, 0);
          xCursor += s;
        }
        for(const [_,xy] of coords){
          const y = xy[1];
          const d = Math.round(y/(nodeH+vGap));
          if(d>maxDepth) maxDepth=d;
        }
        const totalSlots=xCursor||1;
        const width  = totalSlots*(nodeW+hGap)-hGap;
        const height = (maxDepth+1)*(nodeH+vGap)-vGap;
        return { coords: [...coords.entries()], width, height };
      }
      function filterSubtree(forest, rootId){
        if(!rootId || !forest.byId.has(String(rootId))) return forest;
        const id = String(rootId);
        const byId = new Map(); const children = new Map(); const roots=[id];
        function collect(x){
          const n = forest.byId.get(x); if(!n) return;
          byId.set(x, n);
          const ch = forest.children.get(x)||[];
          children.set(x, ch.filter(c=>forest.byId.has(c)));
          for(const c of ch) collect(c);
        }
        collect(id);
        return {byId, children, roots};
      }
      onmessage = (e)=>{
        const { type, payload } = e.data;
        if(type==='layout'){
          try{
            const { raw, opts, rootId } = payload;
            const nodes = normalize(raw);
            const forest = buildForest(nodes);
            const focus = filterSubtree(forest, rootId);
            const out = layoutForest(focus, opts);
            const compact = {};
            for(const [id,n] of focus.byId.entries()){
              compact[id] = [n.name||'', n.title||'', n.department||'', !!n.collapsed, n.managerId==null?null:String(n.managerId)];
            }
            postMessage({ ok:true, coords: out.coords, width: out.width, height: out.height, meta: compact, children: [...focus.children.entries()] });
          }catch(err){
            postMessage({ ok:false, error: String(err && err.message || err) });
          }
        }else if(type==='toggle'){
          try{
            const { id, raw, opts, rootId } = payload;
            const nodes = normalize(raw);
            const forest = buildForest(nodes);
            const n = forest.byId.get(String(id)); if(n){ n.collapsed = !n.collapsed; }
            const focus = filterSubtree(forest, rootId);
            const out = layoutForest(focus, opts);
            const compact = {};
            for(const [id2,n2] of focus.byId.entries()){
              compact[id2] = [n2.name||'', n2.title||'', n2.department||'', !!n2.collapsed, n2.managerId==null?null:String(n2.managerId)];
            }
            postMessage({ ok:true, coords: out.coords, width: out.width, height: out.height, meta: compact, children: [...focus.children.entries()] });
          }catch(err){
            postMessage({ ok:false, error: String(err && err.message || err) });
          }
        }
      };
    `;
    const worker = new Worker(URL.createObjectURL(new Blob([layoutWorkerSrc], {type:'text/javascript'})));

    // ================== App state ==================
    const canvas = document.getElementById('chart');
    const wrap = document.getElementById('canvasWrap');
    const overlay = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    let RAW = [];           // original data array (flat)
    let META = {};          // id -> [name,title,dept,collapsed,managerId]
    let CHILDREN = [];      // [id, [childId,...]]
    let COORDS = [];        // [[id,[x,y]], ...]
    let LAYOUT_W = 0, LAYOUT_H = 0;

    const state = {
      nodeW: 220, nodeH: 80, hGap: 48, vGap: 96,
      depthLimit: 3,
      scale: 1, offsetX: 20, offsetY: 20,
      rootId: null,
      edit: false,
    };

    const undoStack = [];
    const MAX_UNDO = 50;

    // ================== Helpers ==================
    function dprResize() {
      const dpr = window.devicePixelRatio || 1;
      const w = wrap.clientWidth, h = wrap.clientHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    function toScreen(x, y) { return [ (x*state.scale + state.offsetX), (y*state.scale + state.offsetY) ]; }
    function toLayout(sx, sy) { return [ (sx - state.offsetX)/state.scale, (sy - state.offsetY)/state.scale ]; }

    function autoFit(pad = 40) {
      if (!COORDS.length) { draw(); return; }
      const w = wrap.clientWidth, h = wrap.clientHeight;
      const nodeW = state.nodeW, nodeH = state.nodeH;

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const [,xy] of COORDS) {
        const x = xy[0], y = xy[1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x + nodeW > maxX) maxX = x + nodeW;
        if (y + nodeH > maxY) maxY = y + nodeH;
      }
      const contentW = (maxX - minX) + pad*2;
      const contentH = (maxY - minY) + pad*2;

      const sX = w / contentW, sY = h / contentH;
      const s = Math.max(0.2, Math.min(2.5, Math.min(sX, sY)));

      state.scale = s;
      const cx = minX + (maxX - minX)/2;
      const cy = minY + (maxY - minY)/2;
      state.offsetX = w/2 - cx * s;
      state.offsetY = h/2 - cy * s;

      draw();
    }

    function requestLayout(toggleId=null){
      const opts = { nodeW: state.nodeW, nodeH: state.nodeH, hGap: state.hGap, vGap: state.vGap, depthLimit: state.depthLimit };
      if(toggleId){
        worker.postMessage({ type:'toggle', payload: { id: toggleId, raw: RAW, opts, rootId: state.rootId } });
      }else{
        worker.postMessage({ type:'layout', payload: { raw: RAW, opts, rootId: state.rootId } });
      }
    }

    worker.onmessage = (e)=>{
      const { ok, error, coords, width, height, meta, children } = e.data || {};
      if(!ok){ alert('Layout error: ' + error); return; }
      COORDS = coords || [];
      META = meta || {};
      CHILDREN = children || [];
      LAYOUT_W = width || 0;
      LAYOUT_H = height || 0;
      getCoord.cache = null;
      autoFit(); // auto-center/scale to content after every render
    };

    function draw(){
      dprResize();
      ctx.save();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const [lx0, ly0] = toLayout(0,0);
      const [lx1, ly1] = toLayout(canvas.clientWidth, canvas.clientHeight);
      const visPad = 200;
      const minX = lx0 - visPad, maxX = lx1 + visPad;
      const minY = ly0 - visPad, maxY = ly1 + visPad;

      const nodeW = state.nodeW, nodeH = state.nodeH;
      const childMap = new Map(CHILDREN);

      // edges
      ctx.strokeStyle = '#CBD5E1';
      ctx.lineWidth = 1.25;
      for(const [pid, kids] of childMap){
        const metaP = META[pid]; if(!metaP) continue;
        if(metaP[3]) continue;
        const pxy = getCoord(pid); if(!pxy) continue;
        const px = pxy[0] + nodeW/2, py = pxy[1] + nodeH;
        for(const cid of kids){
          const cxy = getCoord(cid); if(!cxy) continue;
          const ex0 = Math.min(px, cxy[0] + nodeW/2), ex1 = Math.max(px, cxy[0] + nodeW/2);
          const ey0 = Math.min(py, cxy[1]), ey1 = Math.max(py, cxy[1]);
          if(ex1 < minX || ex0 > maxX || ey1 < minY || ey0 > maxY) continue;
          const midY = (py + cxy[1]) / 2;
          const [sx, sy] = toScreen(px, py);
          const [mx1, my1] = toScreen(px, midY);
          const [mx2, my2] = toScreen(cxy[0] + nodeW/2, midY);
          const [tx, ty] = toScreen(cxy[0] + nodeW/2, cxy[1]);
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.bezierCurveTo(mx1, my1, mx2, my2, tx, ty);
          ctx.stroke();
        }
      }

      // nodes
      for(const [id, xy] of COORDS){
        const x = xy[0], y = xy[1];
        if(x > maxX || (x+nodeW) < minX || y > maxY || (y+nodeH) < minY) continue;
        const [sx, sy] = toScreen(x, y);
        drawNode(id, sx, sy, nodeW*state.scale, nodeH*state.scale);
      }

      // drag overlay outline (if active)
      if(drag.active){
        const [sx, sy] = toScreen(drag.anchorLayoutX, drag.anchorLayoutY);
        ctx.setLineDash([6,4]);
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = '#3B82F6';
        roundedRect(ctx, drag.mouseX - drag.ghostW/2, drag.mouseY - drag.ghostH/2, drag.ghostW, drag.ghostH, 12*state.scale);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.restore();
    }

    function getCoord(id){
      if(!getCoord.cache) getCoord.cache = new Map();
      if(getCoord.cache.has(id)) return getCoord.cache.get(id);
      for(const [k, v] of COORDS){ if(k===id){ getCoord.cache.set(id, v); return v; } }
      return null;
    }

    function roundedRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }
    function measureText(ctx, s){
      const m = ctx.measureText(String(s));
      return (m.actualBoundingBoxLeft || 0) + (m.actualBoundingBoxRight || 0) + m.width || m.width;
    }
    function textTrunc(ctx, text, x, y, maxW){
      const s = String(text||'');
      if(ctx.measureText(s).width <= maxW){ ctx.fillText(s, x, y); return; }
      let lo=0, hi=s.length, mid;
      while(lo<hi){
        mid = ((lo+hi+1)>>1);
        if(ctx.measureText(s.slice(0,mid)+'…').width <= maxW) lo=mid; else hi=mid-1;
      }
      ctx.fillText(s.slice(0,lo)+'…', x, y);
    }

    function drawNode(id, sx, sy, w, h){
      // base card
      roundedRect(ctx, sx, sy, w, h, 12);
      ctx.fillStyle = '#FFFFFF';
      ctx.strokeStyle = '#94A3B8';
      ctx.lineWidth = 1;
      ctx.fill();
      ctx.stroke();

      const meta = META[id] || ['', '', '', false, null];
      const name = meta[0], title = meta[1], dept = meta[2], collapsed = meta[3];

      // name
      ctx.fillStyle = '#0F172A';
      ctx.font = `${Math.max(12*state.scale,10)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textBaseline = 'top';
      const padX = 10*state.scale, padY = 10*state.scale;
      textTrunc(ctx, name, sx + padX, sy + padY, w - 2*padX);

      // title
      ctx.fillStyle = '#64748B';
      ctx.font = `${Math.max(11*state.scale,9)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      textTrunc(ctx, title, sx + padX, sy + padY + 18*state.scale, w - 2*padX);

      // dept badge
      if(dept){
        const badge = String(dept);
        const bw = Math.min(measureText(ctx, badge) + 12*state.scale, w - 2*padX);
        const bh = 18*state.scale;
        const bx = sx + padX, by = sy + h - bh - 8*state.scale;
        roundedRect(ctx, bx, by, bw, bh, 9*state.scale);
        ctx.fillStyle = '#F8FAFC'; ctx.fill();
        ctx.strokeStyle = '#E2E8F0'; ctx.stroke();
        ctx.fillStyle = '#334155';
        ctx.font = `${Math.max(10*state.scale,8)}px system-ui`;
        ctx.textBaseline = 'middle';
        ctx.fillText(badge, bx + 6*state.scale, by + bh/2);
      }

      // toggle indicator
      const kids = (new Map(CHILDREN)).get(id) || [];
      if(kids.length){
        const r = 10*state.scale;
        const cx = sx + w - r - 6*state.scale, cy = sy + r + 6*state.scale;
        roundedRect(ctx, cx-r, cy-r, 2*r, 2*r, r);
        ctx.fillStyle = collapsed ? '#F1F5F9' : '#EEF2FF';
        ctx.strokeStyle = collapsed ? '#CBD5E1' : '#C7D2FE';
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = collapsed ? '#334155' : '#3730A3';
        ctx.font = `${Math.max(11*state.scale,9)}px system-ui`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(collapsed?'+':'−', cx, cy + (navigator.platform.includes('Win')?1:0));
      }

      // highlight for potential drop target
      if (drag.active && drag.targetId === id) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#3B82F6';
        roundedRect(ctx, sx-2, sy-2, w+4, h+4, 14);
        ctx.stroke();
      }
    }

    // ================== Interaction: pan/zoom + picking ==================
    let isPanning=false, lastX=0, lastY=0, spaceDown=false;

    wrap.addEventListener('mousedown', (e)=>{
      if(spaceDown || e.button===1){ isPanning=true; lastX=e.clientX; lastY=e.clientY; e.preventDefault(); }
      else if (state.edit) beginDrag(e);
    });
    window.addEventListener('mouseup', (e)=>{ if (drag.active) endDrag(e); isPanning=false; });
    window.addEventListener('mousemove', (e)=>{
      if(!isPanning && !drag.active) return;
      if (isPanning) {
        const dx=e.clientX-lastX, dy=e.clientY-lastY;
        lastX=e.clientX; lastY=e.clientY;
        state.offsetX += dx; state.offsetY += dy;
        draw();
      } else if (drag.active) moveDrag(e);
    });
    window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ spaceDown=true; e.preventDefault(); }});
    window.addEventListener('keyup',   (e)=>{ if(e.code==='Space'){ spaceDown=false; }});

    wrap.addEventListener('wheel', (e)=>{
      const delta = -Math.sign(e.deltaY) * 0.1;
      state.scale = Math.min(2.5, Math.max(0.25, state.scale * (1 + delta)));
      const rect = wrap.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      const [lx, ly] = toLayout(cx, cy);
      state.offsetX = cx - lx*state.scale;
      state.offsetY = cy - ly*state.scale;
      e.preventDefault();
      draw();
    }, { passive:false });

    // Click to toggle (only when not in edit mode)
    wrap.addEventListener('click', (e)=>{
      if(isPanning || state.edit) return;
      const rect = wrap.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      const [lx, ly] = toLayout(x, y);
      const w = state.nodeW, h = state.nodeH;
      for(const [id, xy] of COORDS){
        const nx = xy[0], ny = xy[1];
        if(lx>=nx && lx<=nx+w && ly>=ny && ly<=ny+h){
          requestLayout(id);
          getCoord.cache = null;
          return;
        }
      }
    });

    // ================== Drag & drop (Edit mode) ==================
    const drag = {
      active: false,
      id: null,
      mouseX: 0,
      mouseY: 0,
      anchorLayoutX: 0,
      anchorLayoutY: 0,
      ghostW: 0,
      ghostH: 0,
      targetId: null,
      startManager: null
    };

    function hitNode(layoutX, layoutY){
      const w = state.nodeW, h = state.nodeH;
      for(const [id, xy] of COORDS){
        const nx = xy[0], ny = xy[1];
        if(layoutX>=nx && layoutX<=nx+w && layoutY>=ny && layoutY<=ny+h) return id;
      }
      return null;
    }

    function beginDrag(e){
      const rect = wrap.getBoundingClientRect();
      const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
      const [lx, ly] = toLayout(sx, sy);
      const id = hitNode(lx, ly);
      if(!id) return; // clicked empty
      drag.active = true;
      drag.id = id;
      drag.mouseX = sx; drag.mouseY = sy;
      drag.anchorLayoutX = getCoord(id)[0];
      drag.anchorLayoutY = getCoord(id)[1];
      drag.ghostW = state.nodeW * state.scale;
      drag.ghostH = state.nodeH * state.scale;
      drag.targetId = null;
      drag.startManager = META[id] ? META[id][4] : null; // original managerId
      e.preventDefault();
      draw();
    }
    function moveDrag(e){
      const rect = wrap.getBoundingClientRect();
      drag.mouseX = e.clientX - rect.left;
      drag.mouseY = e.clientY - rect.top;
      // potential drop target
      const [lx, ly] = toLayout(drag.mouseX, drag.mouseY);
      let target = hitNode(lx, ly);
      if (target === drag.id) target = null;
      // prevent dropping on own descendant
      if (target && isDescendant(target, drag.id)) target = null;
      drag.targetId = target || null;
      draw();
    }
    function endDrag(e){
      const changed = (drag.active && drag.targetId);
      if (changed) {
        const before = snapshotManagers();
        // apply change locally
        const targetId = drag.targetId;
        const nodeIdx = RAW.findIndex(n => String(n.id) === String(drag.id));
        if (nodeIdx >= 0) {
          RAW[nodeIdx].managerId = String(targetId);
          // optional: also remove from reports arrays if your data had them
        }
        pushUndo(before);
        requestLayout(); // relayout after change
      }
      drag.active = false;
      drag.id = null;
      drag.targetId = null;
      draw();
    }

    function isDescendant(candidateId, ancestorId){
      // build a quick children map
      const map = new Map(CHILDREN);
      const stack = [ancestorId];
      const seen = new Set();
      while(stack.length){
        const cur = stack.pop();
        if (cur === candidateId) return true;
        if (seen.has(cur)) continue;
        seen.add(cur);
        const kids = map.get(cur) || [];
        for (const k of kids) stack.push(k);
      }
      return false;
    }

    function snapshotManagers(){
      // keep it small: only id -> managerId mapping
      const snap = {};
      for (const n of RAW) snap[String(n.id)] = (n.managerId==null?null:String(n.managerId));
      return snap;
    }
    function pushUndo(before){
      undoStack.push(before);
      while(undoStack.length > MAX_UNDO) undoStack.shift();
      document.getElementById('undoBtn').disabled = undoStack.length === 0;
    }

    // ================== Controls wiring ==================
    const nodeW = document.getElementById('nodeW');
    const hGap  = document.getElementById('hGap');
    const vGap  = document.getElementById('vGap');
    const maxDepth = document.getElementById('maxDepth');
    const fitBtn = document.getElementById('fitBtn');
    const expandAllBtn = document.getElementById('expandAllBtn');
    const collapseAllBtn = document.getElementById('collapseAllBtn');
    const editMode = document.getElementById('editMode');
    const undoBtn = document.getElementById('undoBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    nodeW.addEventListener('input', (e)=>{ const v=parseInt(e.target.value,10)||220; nodeW.setAttribute('aria-valuenow', String(v)); state.nodeW = v; requestLayout(); });
    hGap.addEventListener('input',  (e)=>{ const v=parseInt(e.target.value,10)||48;  hGap.setAttribute('aria-valuenow', String(v));  state.hGap  = v; requestLayout(); });
    vGap.addEventListener('input',  (e)=>{ const v=parseInt(e.target.value,10)||96;  vGap.setAttribute('aria-valuenow', String(v));  state.vGap  = v; requestLayout(); });
    maxDepth.addEventListener('change', (e)=>{ state.depthLimit = Math.max(1, parseInt(e.target.value,10)||3); requestLayout(); });

    fitBtn.addEventListener('click', ()=>{ autoFit(); });
    expandAllBtn.addEventListener('click', ()=>{ RAW.forEach(r=>{ r.collapsed=false; }); requestLayout(); });
    collapseAllBtn.addEventListener('click', ()=>{ RAW.forEach(r=>{ r.collapsed=true; }); requestLayout(); });

    editMode.addEventListener('change', (e)=>{ state.edit = !!e.target.checked; });

    undoBtn.addEventListener('click', ()=>{
      if(!undoStack.length) return;
      const last = undoStack.pop();
      for (const n of RAW) {
        const v = last[String(n.id)];
        n.managerId = (v==null?null:String(v));
      }
      document.getElementById('undoBtn').disabled = undoStack.length === 0;
      requestLayout();
    });

    downloadBtn.addEventListener('click', ()=>{
      const blob = new Blob([JSON.stringify(RAW, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'org_edited.json';
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
    });

    // Data + render
    const fileInput = document.getElementById('fileInput');
    const loadBtn = document.getElementById('loadBtn');
    const renderBtn = document.getElementById('renderBtn');
    const sampleBtn = document.getElementById('sampleBtn');
    const jsonInput = document.getElementById('jsonInput');
    const rootId = document.getElementById('rootId');

    loadBtn.addEventListener('click', async ()=>{
      const f = fileInput.files?.[0]; if(!f){ alert('Pick a JSON file'); return; }
      const text = await f.text();
      jsonInput.value = text;
      renderBtn.click();
    });

    renderBtn.addEventListener('click', ()=>{
      try{
        RAW = JSON.parse(jsonInput.value);
        // default nodes open
        RAW.forEach(r=>{ r.collapsed=false; });
        const rid = (rootId.value||'').trim();
        state.rootId = rid || null;
        if (rid) {
          const exists = RAW.some(r => String(r.id) === rid);
          if (!exists) {
            alert('Root ID not found in data. Rendering full org instead.');
            state.rootId = null;
          }
        }
        requestLayout();
      }catch(e){ alert('Invalid JSON: ' + e.message); }
    });

    sampleBtn.addEventListener('click', ()=>{
      const sample = [];
      sample.push({id:'ceo', displayName:'CEO', jobTitle:'Chief Executive Officer', department:'Exec', managerId:null, reports:['vp1','vp2','vp3']});
      for(let i=1;i<=3;i++){
        const vp = `vp${i}`;
        sample.push({id:vp, displayName:`VP ${i}`, jobTitle:'Vice President', department:'Dept '+i, managerId:'ceo', reports:[`m${i}a`,`m${i}b`,`m${i}c`]});
        ['a','b','c'].forEach((s)=>{
          const mid = `m${i}${s}`;
          sample.push({id:mid, displayName:`Mgr ${i}${s.toUpperCase()}`, jobTitle:'Manager', department:'Ops', managerId:vp, reports:[`ic${i}${s}1`,`ic${i}${s}2`,`ic${i}${s}3`,`ic${i}${s}4`]});
          for(let k=1;k<=4;k++){
            sample.push({id:`ic${i}${s}${k}`, displayName:`IC ${i}${s}${k}`, jobTitle:'Engineer', department:'IMSD', managerId:mid});
          }
        });
      }
      jsonInput.value = JSON.stringify(sample, null, 2);
      rootId.value = '';
      renderBtn.click();
    });

    // Search
    const searchBox = document.getElementById('searchBox');
    const searchBtn = document.getElementById('searchBtn');
    const searchInfo = document.getElementById('searchInfo');

    searchBtn.addEventListener('click', ()=>{
      const q = (searchBox.value||'').toLowerCase().trim();
      if(!q){ searchInfo.textContent=''; return; }
      let bestId=null, bestScore=-1;
      for(const [id, m] of Object.entries(META)){
        const name=(m[0]||'').toLowerCase(), title=(m[1]||'').toLowerCase();
        let score = 0;
        if(name.includes(q)) score+=2;
        if(title.includes(q)) score+=1;
        if(id.toLowerCase().includes(q)) score+=1;
        if(score>bestScore){ bestScore=score; bestId=id; }
      }
      if(!bestId){ searchInfo.textContent='No match.'; return; }
      const xy = getCoord(bestId); if(!xy){ searchInfo.textContent='Found, but not laid out.'; return; }
      const [x,y] = xy;
      const centerX = wrap.clientWidth/2, centerY = wrap.clientHeight/2;
      state.offsetX = centerX - (x + state.nodeW/2)*state.scale;
      state.offsetY = centerY - (y + state.nodeH/2)*state.scale;
      searchInfo.textContent = `Centered: ${META[bestId][0]} (${bestId})`;
      draw();
    });

    // Init
    dprResize();
  </script>
</body>
</html>
