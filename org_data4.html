<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Org Chart — Pro</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html { -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }
    html, body { height: 100%; }
    #canvasWrap { touch-action: none; }
    @supports (scrollbar-width: none) { .no-scrollbar { scrollbar-width: none; } }
    .no-scrollbar { -ms-overflow-style: none; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    .toast { animation: toast-in .18s ease-out; }
    @keyframes toast-in { from { transform: translateY(6px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Top App Bar -->
  <header class="sticky top-0 z-20 bg-white/80 backdrop-blur border-b border-slate-200">
    <div class="max-w-7xl mx-auto px-4 py-3 flex flex-wrap items-center gap-3">
      <div class="flex items-center gap-2">
        <div class="h-8 w-8 rounded-xl bg-indigo-600 text-white grid place-items-center font-bold">OC</div>
        <h1 class="text-lg font-semibold tracking-tight">Org Chart</h1>
      </div>
      <div class="grow"></div>
      <div class="flex items-center gap-2">
        <label class="flex items-center gap-2 text-sm border rounded-xl px-3 py-1.5 bg-white" title="Enable drag and drop editing">
          <span class="text-slate-600">Edit mode</span>
          <input id="editMode" type="checkbox" class="w-4 h-4" aria-label="Toggle edit mode">
        </label>
        <button id="undoBtn" class="px-3 py-1.5 rounded-xl bg-white border text-slate-900 text-sm hover:bg-slate-50 disabled:opacity-40" type="button" disabled title="Undo last change">Undo</button>
        <div class="hidden sm:block w-px h-6 bg-slate-200 mx-1"></div>
        <button id="downloadBtn" class="px-3 py-1.5 rounded-xl bg-slate-900 text-white text-sm hover:bg-slate-800" type="button" title="Download full JSON">Download JSON</button>
        <button id="exportDeltaBtn" class="px-3 py-1.5 rounded-xl bg-indigo-600 text-white text-sm hover:bg-indigo-500" type="button" title="Export only manager changes">Export Deltas</button>
        <button id="resetBtn" class="px-3 py-1.5 rounded-xl bg-white border text-slate-900 text-sm hover:bg-slate-50" type="button" title="Reset to the original dataset">Reset to Original</button>
      </div>
    </div>
  </header>

  <!-- Toolbar -->
  <section class="border-b border-slate-200 bg-white">
    <div class="max-w-7xl mx-auto px-4 py-3 grid grid-cols-1 xl:grid-cols-3 gap-3">
      <!-- Layout controls -->
      <div class="flex flex-wrap items-center gap-4">
        <div class="flex items-center gap-2">
          <label for="nodeW" class="text-sm text-slate-600">Node width</label>
          <input id="nodeW" type="range" min="140" max="360" value="220" class="accent-slate-800" title="Node width"
                 aria-valuemin="140" aria-valuemax="360" aria-valuenow="220" />
        </div>
        <div class="flex items-center gap-2">
          <label for="hGap" class="text-sm text-slate-600">H gap</label>
          <input id="hGap" type="range" min="24" max="160" value="48" class="accent-slate-800" title="Horizontal gap"
                 aria-valuemin="24" aria-valuemax="160" aria-valuenow="48" />
        </div>
        <div class="flex items-center gap-2">
          <label for="vGap" class="text-sm text-slate-600">V gap</label>
          <input id="vGap" type="range" min="48" max="200" value="96" class="accent-slate-800" title="Vertical gap"
                 aria-valuemin="48" aria-valuemax="200" aria-valuenow="96" />
        </div>
        <div class="flex items-center gap-2">
          <label for="maxDepth" class="text-sm text-slate-600">Max depth</label>
          <input id="maxDepth" type="number" step="1" min="1" value="3" class="w-16 border rounded px-2 py-1" inputmode="numeric" title="Max levels visible"/>
        </div>
        <button id="fitBtn" class="px-3 py-1.5 rounded-xl bg-white border text-slate-900 text-sm hover:bg-slate-50" type="button" title="Fit to screen">Fit</button>
        <button id="expandAllBtn" class="px-3 py-1.5 rounded-xl bg-white border text-slate-900 text-sm hover:bg-slate-50" type="button" title="Expand all">Expand all</button>
        <button id="collapseAllBtn" class="px-3 py-1.5 rounded-xl bg-white border text-slate-900 text-sm hover:bg-slate-50" type="button" title="Collapse all">Collapse all</button>
      </div>

      <!-- Data controls -->
      <div class="flex flex-wrap items-center gap-2">
        <label for="fileInput" class="sr-only">Choose JSON file</label>
        <input id="fileInput" type="file" accept="application/json" class="text-sm" title="Choose JSON file" />
        <button id="loadBtn" class="px-3 py-1.5 rounded-xl bg-slate-900 text-white text-sm hover:bg-slate-800" type="button" title="Load selected file">Load</button>
        <button id="sampleBtn" class="px-3 py-1.5 rounded-xl bg-white border text-slate-900 text-sm hover:bg-slate-50" type="button" title="Load sample data">Sample</button>

        <label for="rootId" class="text-sm text-slate-600 ml-2">Root</label>
        <input id="rootId" type="text" class="border rounded px-2 py-1 text-sm w-36" placeholder="(optional id)" title="Root node id (optional)" />
        <button id="renderBtn" class="px-3 py-1.5 rounded-xl bg-indigo-600 text-white text-sm hover:bg-indigo-500" type="button" title="Render from pasted JSON">Render</button>
      </div>

      <!-- Search -->
      <div class="flex items-center gap-2">
        <label for="searchBox" class="sr-only">Search</label>
        <input id="searchBox" type="text" class="flex-1 border rounded px-3 py-2 text-sm" placeholder="Search: name / title / id" title="Search text"/>
        <button id="searchBtn" class="px-3 py-1.5 rounded-xl bg-white border text-slate-900 text-sm hover:bg-slate-50" type="button" title="Find">Find</button>
        <div id="searchInfo" class="text-xs text-slate-500 ml-2"></div>
      </div>
    </div>
  </section>

  <!-- Paste JSON panel -->
  <section class="bg-white">
    <div class="max-w-7xl mx-auto px-4 pb-3">
      <label for="jsonInput" class="block text-sm text-slate-600 mb-1">Paste JSON (flat list)</label>
      <textarea id="jsonInput" class="w-full h-28 font-mono text-xs p-3 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-slate-300"
        placeholder='[{"id":"ceo","displayName":"CEO","jobTitle":"Chief Executive Officer","department":"Exec","managerId":null,"reports":["vp1","vp2"]}]'
        title="Paste JSON here to render"></textarea>
    </div>
  </section>

  <!-- Chart -->
  <main class="px-2 pb-6">
    <div id="canvasWrap" class="relative bg-white border border-slate-200 rounded-2xl shadow mx-auto max-w-7xl h-[70vh] overflow-hidden">
      <canvas id="chart" class="absolute inset-0"></canvas>
      <div class="absolute bottom-3 right-3 bg-white/90 border border-slate-200 rounded-xl shadow-sm p-2">
        <canvas id="minimap" width="200" height="120"></canvas>
      </div>
      <div id="toasts" class="absolute top-3 left-1/2 -translate-x-1/2 space-y-2"></div>
    </div>
  </main>

  <script>
    // ---------- Toasts ----------
    function toast(msg, flavor='ok') {
      const t = document.createElement('div');
      t.className = 'toast px-3 py-2 rounded-lg text-sm shadow border ' + (flavor==='ok' ? 'bg-white border-slate-200' : 'bg-red-50 border-red-200 text-red-800');
      t.textContent = msg;
      document.getElementById('toasts').appendChild(t);
      setTimeout(() => { t.style.opacity = '0'; t.style.transition='opacity .2s'; }, 1800);
      setTimeout(() => t.remove(), 2100);
    }

    // ---------- Layout Worker ----------
    const layoutWorkerSrc = `
      function normalize(raw){
        const byId = new Map();
        for (const r of raw||[]){
          const id = String(r.id ?? ''); if(!id) continue;
          const name = r.displayName || r.mailNickname || r.userPrincipalName || r.mail || id;
          const title = (typeof r.jobTitle==='string' && r.jobTitle.includes('|')) ? r.jobTitle.split('|')[0] : (r.jobTitle||'');
          byId.set(id, { id, name, title, department: r.department||null, managerId: (r.managerId!=null?r.managerId:null), _reports: Array.isArray(r.reports)?r.reports:[], collapsed: !!r.collapsed });
        }
        for(const n of byId.values()){
          for(const rep of n._reports){
            const cid = typeof rep==='string' ? rep : (rep && rep.id ? String(rep.id) : null);
            if(!cid) continue;
            const child = byId.get(cid);
            if(child && (child.managerId==null || child.managerId==='')) child.managerId = n.id;
          }
        }
        return [...byId.values()];
      }
      function buildForest(nodes){
        const byId = new Map(nodes.map(n => [String(n.id), {...n, id:String(n.id)}]));
        const children = new Map([...byId.keys()].map(k => [k, []]));
        const hasParent = new Set();
        for(const n of byId.values()){
          if(n.managerId!=null && byId.has(String(n.managerId))){
            const pid = String(n.managerId);
            children.get(pid).push(n.id);
            hasParent.add(n.id);
          }
        }
        const roots = [...byId.keys()].filter(k=>!hasParent.has(k));
        for(const [k,arr] of children) arr.sort((a,b)=>{
          const A = (byId.get(a)?.name||'').toLowerCase();
          const B = (byId.get(b)?.name||'').toLowerCase();
          return A.localeCompare(B);
        });
        return {byId, children, roots};
      }
      function layoutForest(forest, opts){
        const { byId, children, roots } = forest;
        const nodeW=opts.nodeW, nodeH=opts.nodeH, hGap=opts.hGap, vGap=opts.vGap, depthLimit=opts.depthLimit|0;
        const subtreeSlots = new Map();
        function slots(id, depth){
          const node = byId.get(id); if(!node) {subtreeSlots.set(id,1); return 1;}
          if(node.collapsed) {subtreeSlots.set(id,1); return 1;}
          if(depthLimit && depth>=depthLimit) {subtreeSlots.set(id,1); return 1;}
          const ch = children.get(id)||[];
          if(!ch.length) {subtreeSlots.set(id,1); return 1;}
          let sum=0; for(const c of ch) sum += slots(c, depth+1);
          subtreeSlots.set(id, Math.max(1,sum)); return subtreeSlots.get(id);
        }
        const coords = new Map();
        function place(id, xOffset, depth){
          const node = byId.get(id); if(!node) return 0;
          const ch = (children.get(id)||[]);
          const visible = node.collapsed || (depthLimit && depth>=depthLimit) ? [] : ch;
          const s = subtreeSlots.get(id) || 1;
          const cx = xOffset + (s-1)/2;
          const x = cx * (nodeW + hGap);
          const y = depth * (nodeH + vGap);
          coords.set(id, [x,y]);
          let childOffset=xOffset;
          for(const c of visible){
            const cs = subtreeSlots.get(c)||1;
            place(c, childOffset, depth+1);
            childOffset += cs;
          }
          return s;
        }
        let xCursor=0; let maxDepth=0;
        const rootsList = roots.length?roots:[...byId.keys()].slice(0,1);
        for(const r of rootsList){
          slots(r,0);
          const s = subtreeSlots.get(r)||1;
          place(r, xCursor, 0);
          xCursor += s;
        }
        for(const [_,xy] of coords){
          const y = xy[1];
          const d = Math.round(y/(nodeH+vGap));
          if(d>maxDepth) maxDepth=d;
        }
        const totalSlots=xCursor||1;
        const width  = totalSlots*(nodeW+hGap)-hGap;
        const height = (maxDepth+1)*(nodeH+vGap)-vGap;
        return { coords: [...coords.entries()], width, height };
      }
      function filterSubtree(forest, rootId){
        if(!rootId || !forest.byId.has(String(rootId))) return forest;
        const id = String(rootId);
        const byId = new Map(); const children = new Map(); const roots=[id];
        function collect(x){
          const n = forest.byId.get(x); if(!n) return;
          byId.set(x, n);
          const ch = forest.children.get(x)||[];
          children.set(x, ch.filter(c=>forest.byId.has(c)));
          for(const c of ch) collect(c);
        }
        collect(id);
        return {byId, children, roots};
      }
      onmessage = (e)=>{
        const { type, payload } = e.data;
        if(type==='layout'){
          try{
            const { raw, opts, rootId } = payload;
            const nodes = normalize(raw);
            const forest = buildForest(nodes);
            const focus = filterSubtree(forest, rootId);
            const out = layoutForest(focus, opts);
            const compact = {};
            for(const [id,n] of focus.byId.entries()){
              compact[id] = [n.name||'', n.title||'', n.department||'', !!n.collapsed, n.managerId==null?null:String(n.managerId)];
            }
            postMessage({ ok:true, coords: out.coords, width: out.width, height: out.height, meta: compact, children: [...focus.children.entries()] });
          }catch(err){
            postMessage({ ok:false, error: String(err && err.message || err) });
          }
        }else if(type==='toggle'){
          try{
            const { id, raw, opts, rootId } = payload;
            const nodes = normalize(raw);
            const forest = buildForest(nodes);
            const n = forest.byId.get(String(id)); if(n){ n.collapsed = !n.collapsed; }
            const focus = filterSubtree(forest, rootId);
            const out = layoutForest(focus, opts);
            const compact = {};
            for(const [id2,n2] of focus.byId.entries()){
              compact[id2] = [n2.name||'', n2.title||'', n2.department||'', !!n2.collapsed, n2.managerId==null?null:String(n2.managerId)];
            }
            postMessage({ ok:true, coords: out.coords, width: out.width, height: out.height, meta: compact, children: [...focus.children.entries()] });
          }catch(err){
            postMessage({ ok:false, error: String(err && err.message || err) });
          }
        }
      };
    `;
    const worker = new Worker(URL.createObjectURL(new Blob([layoutWorkerSrc], {type:'text/javascript'})));

    // ---------- App state ----------
    const canvas = document.getElementById('chart');
    const minimap = document.getElementById('minimap');
    const wrap = document.getElementById('canvasWrap');
    const ctx = canvas.getContext('2d');
    const mctx = minimap.getContext('2d');

    let RAW = [];            // working data
    let ORIG = null;         // original snapshot
    let META = {};           // id -> [name,title,dept,collapsed,managerId]
    let CHILDREN = [];       // [id, [childId,...]]
    let COORDS = [];         // [[id,[x,y]], ...]
    let LAYOUT_W = 0, LAYOUT_H = 0;

    const state = {
      nodeW: 220, nodeH: 84, hGap: 48, vGap: 96,
      depthLimit: 3,
      scale: 1, offsetX: 20, offsetY: 20,
      rootId: null,
      edit: false,
      hoverId: null,
      pulseTargets: new Map(),
    };

    const undoStack = [];
    const MAX_UNDO = 100;

    // ---------- Helpers ----------
    function dprResize() {
      const dpr = window.devicePixelRatio || 1;
      const w = wrap.clientWidth, h = wrap.clientHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    function toScreen(x, y) { return [ (x*state.scale + state.offsetX), (y*state.scale + state.offsetY) ]; }
    function toLayout(sx, sy) { return [ (sx - state.offsetX)/state.scale, (sy - state.offsetY)/state.scale ]; }

    function hashPastel(s){ let h=0; for(let i=0;i<s.length;i++) h=(h*31+s.charCodeAt(i))>>>0; return `hsl(${h%360} 80% 95%)`; }
    function hashStroke(s){ let h=0; for(let i=0;i<s.length;i++) h=(h*31+s.charCodeAt(i))>>>0; return `hsl(${h%360} 50% 70%)`; }

    function autoFit(pad = 40) {
      if (!COORDS.length) { draw(); return; }
      const w = wrap.clientWidth, h = wrap.clientHeight;
      const nodeW = state.nodeW, nodeH = state.nodeH;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const [,xy] of COORDS) {
        const x = xy[0], y = xy[1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x + nodeW > maxX) maxX = x + nodeW;
        if (y + nodeH > maxY) maxY = y + nodeH;
      }
      const contentW = Math.max(1, (maxX - minX) + pad*2);
      const contentH = Math.max(1, (maxY - minY) + pad*2);
      const sX = w / contentW, sY = h / contentH;
      const s = Math.max(0.2, Math.min(2.5, Math.min(sX, sY)));
      state.scale = s;
      const cx = minX + (maxX - minX)/2;
      const cy = minY + (maxY - minY)/2;
      state.offsetX = w/2 - cx * s;
      state.offsetY = h/2 - cy * s;
      draw();
      drawMinimap();
    }

    function requestLayout(toggleId=null){
      const opts = { nodeW: state.nodeW, nodeH: state.nodeH, hGap: state.hGap, vGap: state.vGap, depthLimit: state.depthLimit };
      if(toggleId){
        worker.postMessage({ type:'toggle', payload: { id: toggleId, raw: RAW, opts, rootId: state.rootId } });
      }else{
        worker.postMessage({ type:'layout', payload: { raw: RAW, opts, rootId: state.rootId } });
      }
    }

    worker.onmessage = (e)=>{
      const { ok, error, coords, width, height, meta, children } = e.data || {};
      if(!ok){ alert('Layout error: ' + error); return; }
      COORDS = coords || [];
      META = meta || {};
      CHILDREN = children || [];
      LAYOUT_W = width || 0;
      LAYOUT_H = height || 0;
      getCoord.cache = null;
      autoFit();
    };

    function getCoord(id){
      if(!getCoord.cache) getCoord.cache = new Map();
      if(getCoord.cache.has(id)) return getCoord.cache.get(id);
      for(const [k, v] of COORDS){ if(k===id){ getCoord.cache.set(id, v); return v; } }
      return null;
    }

    function roundedRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }
    function measureText(ctx, s){
      const m = ctx.measureText(String(s));
      return (m.actualBoundingBoxLeft || 0) + (m.actualBoundingBoxRight || 0) + m.width || m.width;
    }
    function textTrunc(ctx, text, x, y, maxW){
      const s = String(text||'');
      if(ctx.measureText(s).width <= maxW){ ctx.fillText(s, x, y); return; }
      let lo=0, hi=s.length, mid;
      while(lo<hi){ mid=((lo+hi+1)>>1); if(ctx.measureText(s.slice(0,mid)+'…').width <= maxW) lo=mid; else hi=mid-1; }
      ctx.fillText(s.slice(0,lo)+'…', x, y);
    }

    function draw(){
      dprResize();
      ctx.save();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const [lx0, ly0] = toLayout(0,0);
      const [lx1, ly1] = toLayout(canvas.clientWidth, canvas.clientHeight);
      const visPad = 240;
      const minX = lx0 - visPad, maxX = lx1 + visPad;
      const minY = ly0 - visPad, maxY = ly1 + visPad;

      const nodeW = state.nodeW, nodeH = state.nodeH;
      const childMap = new Map(CHILDREN);

      // edges
      ctx.strokeStyle = '#E2E8F0';
      ctx.lineWidth = 1.2;
      for(const [pid, kids] of childMap){
        const metaP = META[pid]; if(!metaP) continue;
        if(metaP[3]) continue;
        const pxy = getCoord(pid); if(!pxy) continue;
        const px = pxy[0] + nodeW/2, py = pxy[1] + nodeH;
        for(const cid of kids){
          const cxy = getCoord(cid); if(!cxy) continue;
          const ex0 = Math.min(px, cxy[0] + nodeW/2), ex1 = Math.max(px, cxy[0] + nodeW/2);
          const ey0 = Math.min(py, cxy[1]), ey1 = Math.max(py, cxy[1]);
          if(ex1 < minX || ex0 > maxX || ey1 < minY || ey0 > maxY) continue;
          const midY = (py + cxy[1]) / 2;
          const [sx, sy] = toScreen(px, py);
          const [mx1, my1] = toScreen(px, midY);
          const [mx2, my2] = toScreen(cxy[0] + nodeW/2, midY);
          const [tx, ty] = toScreen(cxy[0] + nodeW/2, cxy[1]);
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.bezierCurveTo(mx1, my1, mx2, my2, tx, ty);
          ctx.stroke();
        }
      }

      // nodes
      for(const [id, xy] of COORDS){
        const x = xy[0], y = xy[1];
        if(x > maxX || (x+nodeW) < minX || y > maxY || (y+nodeH) < minY) continue;
        const [sx, sy] = toScreen(x, y);
        drawNode(id, sx, sy, nodeW*state.scale, nodeH*state.scale);
      }

      // drag ghost
      if(drag.active){
        ctx.setLineDash([6,4]);
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = '#3B82F6';
        roundedRect(ctx, drag.mouseX - drag.ghostW/2, drag.mouseY - drag.ghostH/2, drag.ghostW, drag.ghostH, 12*state.scale);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      ctx.restore();
      drawMinimap();

      // loop for pulse
      let anyPulse=false;
      for(const [,until] of state.pulseTargets){ if(performance.now()<until){ anyPulse=true; break; } }
      if(anyPulse) requestAnimationFrame(draw);
    }

    function drawNode(id, sx, sy, w, h){
      const meta = META[id] || ['', '', '', false, null];
      const name = meta[0], title = meta[1], dept = meta[2], collapsed = meta[3];
      const hovered = (state.hoverId === id);
      const bg = dept ? hashPastel(dept) : '#FFFFFF';
      const stroke = dept ? hashStroke(dept) : '#94A3B8';
      if (hovered || drag.targetId === id) { ctx.shadowColor='rgba(59,130,246,0.25)'; ctx.shadowBlur=18; ctx.shadowOffsetY=2; }
      roundedRect(ctx, sx, sy, w, h, 12); ctx.fillStyle = bg; ctx.fill(); ctx.shadowBlur=0; ctx.shadowOffsetY=0;
      ctx.strokeStyle = stroke; ctx.lineWidth = 1; ctx.stroke();

      ctx.fillStyle = '#0F172A';
      ctx.font = `${Math.max(12*state.scale,10)}px Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Arial`;
      ctx.textBaseline = 'top';
      const padX = 12*state.scale, padY = 10*state.scale;
      textTrunc(ctx, name, sx + padX, sy + padY, w - 2*padX);

      ctx.fillStyle = '#475569';
      ctx.font = `${Math.max(11*state.scale,9)}px Inter, ui-sans-serif, system-ui`;
      textTrunc(ctx, title, sx + padX, sy + padY + 18*state.scale, w - 2*padX);

      if(dept){
        const badge = String(dept);
        const bh = 18*state.scale;
        const bw = Math.min(measureText(ctx, badge) + 12*state.scale, w - 2*padX);
        const bx = sx + padX, by = sy + h - bh - 8*state.scale;
        roundedRect(ctx, bx, by, bw, bh, 9*state.scale);
        ctx.fillStyle = '#F8FAFC'; ctx.fill();
        ctx.strokeStyle = '#E2E8F0'; ctx.stroke();
        ctx.fillStyle = '#334155';
        ctx.font = `${Math.max(10*state.scale,8)}px Inter, ui-sans-serif`;
        ctx.textBaseline = 'middle';
        ctx.fillText(badge, bx + 6*state.scale, by + bh/2);
      }

      const kids = (new Map(CHILDREN)).get(id) || [];
      if(kids.length){
        const r = 10*state.scale;
        const cx = sx + w - r - 6*state.scale, cy = sy + r + 6*state.scale;
        roundedRect(ctx, cx-r, cy-r, 2*r, 2*r, r);
        ctx.fillStyle = collapsed ? '#F1F5F9' : '#EEF2FF';
        ctx.strokeStyle = collapsed ? '#CBD5E1' : '#C7D2FE';
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = collapsed ? '#334155' : '#3730A3';
        ctx.font = `${Math.max(11*state.scale,9)}px Inter, ui-sans-serif`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(collapsed?'+':'−', cx, cy + (navigator.platform.includes('Win')?1:0));
      }

      const until = state.pulseTargets.get(id);
      if (until && performance.now() < until) {
        const pct = 1 - ((until - performance.now()) / 900);
        const alpha = 0.35 * (1 - pct);
        ctx.strokeStyle = `rgba(59,130,246,${alpha})`;
        ctx.lineWidth = 6 * state.scale * (1 + pct);
        roundedRect(ctx, sx - 4 - pct*8, sy - 4 - pct*8, w + 8 + pct*16, h + 8 + pct*16, (12+6*pct)*state.scale);
        ctx.stroke();
      }
    }

    // ---------- Minimap ----------
    function drawMinimap(){
      const mw = minimap.width, mh = minimap.height;
      mctx.clearRect(0,0,mw,mh);
      if(!LAYOUT_W || !LAYOUT_H) return;
      mctx.fillStyle = '#F8FAFC'; mctx.fillRect(0,0,mw,mh);
      mctx.strokeStyle = '#E2E8F0'; mctx.strokeRect(0.5,0.5,mw-1,mh-1);
      const ms = Math.min(mw / LAYOUT_W, mh / LAYOUT_H);
      mctx.fillStyle = '#CBD5E1';
      for (const [,xy] of COORDS) mctx.fillRect(xy[0]*ms, xy[1]*ms, 2, 2);
      const [lx0, ly0] = toLayout(0, 0);
      const [lx1, ly1] = toLayout(canvas.clientWidth, canvas.clientHeight);
      const vx = Math.max(0, lx0) * ms, vy = Math.max(0, ly0) * ms;
      const vw = Math.min(LAYOUT_W, lx1) * ms - vx, vh = Math.min(LAYOUT_H, ly1) * ms - vy;
      mctx.strokeStyle = '#3B82F6'; mctx.lineWidth = 1;
      mctx.strokeRect(vx, vy, Math.max(10, vw), Math.max(10, vh));
    }
    minimap.addEventListener('mousedown', (e)=>{
      if(!LAYOUT_W||!LAYOUT_H) return;
      const rect = minimap.getBoundingClientRect();
      const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
      const ms = Math.min(minimap.width / LAYOUT_W, minimap.height / LAYOUT_H);
      const lx = cx / ms, ly = cy / ms;
      const cw = wrap.clientWidth, ch = wrap.clientHeight;
      state.offsetX = cw/2 - lx*state.scale;
      state.offsetY = ch/2 - ly*state.scale;
      draw(); drawMinimap();
    });

    // ---------- Interaction ----------
    let isPanning=false, lastX=0, lastY=0, spaceDown=false;

    wrap.addEventListener('mousemove', (e)=>{
      const rect = wrap.getBoundingClientRect();
      const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
      const [lx, ly] = toLayout(sx, sy);
      state.hoverId = hitNode(lx, ly);
      wrap.style.cursor = (state.hoverId && !state.edit) ? 'pointer' : (isPanning ? 'grabbing' : (spaceDown ? 'grab' : 'default'));
      if (drag.active) moveDrag(e);
    });

    wrap.addEventListener('mousedown', (e)=>{
      if(spaceDown || e.button===1){ isPanning=true; lastX=e.clientX; lastY=e.clientY; e.preventDefault(); wrap.style.cursor='grabbing'; }
      else if (state.edit) beginDrag(e);
    });
    window.addEventListener('mouseup', (e)=>{ if (drag.active) endDrag(e); isPanning=false; wrap.style.cursor = 'default'; });
    window.addEventListener('mousemove', (e)=>{
      if(!isPanning) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;
      state.offsetX += dx; state.offsetY += dy;
      draw(); drawMinimap();
    });
    window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ spaceDown=true; e.preventDefault(); wrap.style.cursor='grab'; }});
    window.addEventListener('keyup',   (e)=>{ if(e.code==='Space'){ spaceDown=false; wrap.style.cursor='default'; }});

    wrap.addEventListener('wheel', (e)=>{
      const delta = -Math.sign(e.deltaY) * 0.1;
      const before = state.scale;
      const after = Math.min(2.6, Math.max(0.22, before * (1 + delta)));
      const rect = wrap.getBoundingClientRect();
      const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
      const [lx, ly] = toLayout(cx, cy);
      state.scale = after;
      state.offsetX = cx - lx*after;
      state.offsetY = cy - ly*after;
      e.preventDefault();
      draw(); drawMinimap();
    }, { passive:false });

    wrap.addEventListener('click', (e)=>{
      if(isPanning || state.edit) return;
      const rect = wrap.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      const [lx, ly] = toLayout(x, y);
      const w = state.nodeW, h = state.nodeH;
      for(const [id, xy] of COORDS){
        const nx = xy[0], ny = xy[1];
        if(lx>=nx && lx<=nx+w && ly>=ny && ly<=ny+h){ requestLayout(id); pulse(id); return; }
      }
    });

    function hitNode(layoutX, layoutY){
      const w = state.nodeW, h = state.nodeH;
      for(const [id, xy] of COORDS){
        const nx = xy[0], ny = xy[1];
        if(layoutX>=nx && layoutX<=nx+w && layoutY>=ny && layoutY<=ny+h) return id;
      }
      return null;
    }
    function pulse(id){ state.pulseTargets.set(id, performance.now() + 900); draw(); }

    // ---------- Drag & Drop (Edit) ----------
    const drag = { active:false, id:null, mouseX:0, mouseY:0, anchorLayoutX:0, anchorLayoutY:0, ghostW:0, ghostH:0, targetId:null, startManager:null };

    function beginDrag(e){
      const rect = wrap.getBoundingClientRect();
      const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
      const [lx, ly] = toLayout(sx, sy);
      const id = hitNode(lx, ly);
      if(!id) return;
      drag.active = true; drag.id = id;
      drag.mouseX = sx; drag.mouseY = sy;
      const xy = getCoord(id); drag.anchorLayoutX = xy[0]; drag.anchorLayoutY = xy[1];
      drag.ghostW = state.nodeW * state.scale; drag.ghostH = state.nodeH * state.scale;
      drag.targetId = null; drag.startManager = META[id] ? META[id][4] : null;
      e.preventDefault(); draw();
    }
    function moveDrag(e){
      const rect = wrap.getBoundingClientRect();
      drag.mouseX = e.clientX - rect.left; drag.mouseY = e.clientY - rect.top;
      const [lx, ly] = toLayout(drag.mouseX, drag.mouseY);
      let target = hitNode(lx, ly);
      if (target === drag.id) target = null;
      if (target && isDescendant(target, drag.id)) target = null;
      drag.targetId = target || null; draw();
    }
    function endDrag(){
      const changed = (drag.active && drag.targetId);
      if (changed) {
        const before = snapshotManagers();
        const targetId = drag.targetId;
        const nodeIdx = RAW.findIndex(n => String(n.id) === String(drag.id));
        if (nodeIdx >= 0) RAW[nodeIdx].managerId = String(targetId);
        pushUndo(before); persistLocal(); requestLayout();
        toast(`Reassigned ${META[drag.id]?.[0]||drag.id} → ${META[targetId]?.[0]||targetId}`);
      }
      drag.active = false; drag.id = null; drag.targetId = null; draw();
    }
    function isDescendant(candidateId, ancestorId){
      const map = new Map(CHILDREN); const stack = [ancestorId]; const seen = new Set();
      while(stack.length){ const cur = stack.pop(); if (cur === candidateId) return true; if (seen.has(cur)) continue; seen.add(cur); const kids = map.get(cur) || []; for (const k of kids) stack.push(k); }
      return false;
    }
    function snapshotManagers(){ const snap = {}; for (const n of RAW) snap[String(n.id)] = (n.managerId==null?null:String(n.managerId)); return snap; }
    function pushUndo(before){ undoStack.push(before); while(undoStack.length > MAX_UNDO) undoStack.shift(); document.getElementById('undoBtn').disabled = undoStack.length === 0; }

    // ---------- Controls ----------
    const nodeW = document.getElementById('nodeW');
    const hGap  = document.getElementById('hGap');
    const vGap  = document.getElementById('vGap');
    const maxDepth = document.getElementById('maxDepth');
    const fitBtn = document.getElementById('fitBtn');
    const expandAllBtn = document.getElementById('expandAllBtn');
    const collapseAllBtn = document.getElementById('collapseAllBtn');
    const editMode = document.getElementById('editMode');
    const undoBtn = document.getElementById('undoBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const exportDeltaBtn = document.getElementById('exportDeltaBtn');
    const resetBtn = document.getElementById('resetBtn');

    nodeW.addEventListener('input', (e)=>{ const v=parseInt(e.target.value,10)||220; nodeW.setAttribute('aria-valuenow', String(v)); state.nodeW = v; requestLayout(); });
    hGap.addEventListener('input',  (e)=>{ const v=parseInt(e.target.value,10)||48;  hGap.setAttribute('aria-valuenow', String(v));  state.hGap  = v; requestLayout(); });
    vGap.addEventListener('input',  (e)=>{ const v=parseInt(e.target.value,10)||96;  vGap.setAttribute('aria-valuenow', String(v));  state.vGap  = v; requestLayout(); });
    maxDepth.addEventListener('change', (e)=>{ state.depthLimit = Math.max(1, parseInt(e.target.value,10)||3); requestLayout(); });

    fitBtn.addEventListener('click', ()=> autoFit());
    expandAllBtn.addEventListener('click', ()=>{ RAW.forEach(r=>{ r.collapsed=false; }); requestLayout(); });
    collapseAllBtn.addEventListener('click', ()=>{ RAW.forEach(r=>{ r.collapsed=true; }); requestLayout(); });

    editMode.addEventListener('change', (e)=>{ state.edit = !!e.target.checked; toast(state.edit?'Edit mode ON':'Edit mode OFF'); });

    undoBtn.addEventListener('click', ()=>{
      if(!undoStack.length) return;
      const last = undoStack.pop();
      for (const n of RAW) { const v = last[String(n.id)]; n.managerId = (v==null?null:String(v)); }
      document.getElementById('undoBtn').disabled = undoStack.length === 0;
      persistLocal(); requestLayout(); toast('Undid last change');
    });

    downloadBtn.addEventListener('click', ()=>{
      const blob = new Blob([JSON.stringify(RAW, null, 2)], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'org_edited.json';
      document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
      toast('Downloaded full JSON');
    });

    exportDeltaBtn.addEventListener('click', ()=>{
      if(!ORIG){ toast('No original snapshot to diff against', 'err'); return; }
      const delta = {}; const origMap = new Map(ORIG.map(n => [String(n.id), (n.managerId==null?null:String(n.managerId))]));
      for (const n of RAW) { const id = String(n.id); const before = origMap.get(id); const after = (n.managerId==null?null:String(n.managerId)); if (before !== after) delta[id] = after; }
      const blob = new Blob([JSON.stringify(delta, null, 2)], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'org_deltas.json';
      document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
      toast('Exported deltas JSON');
    });

    resetBtn.addEventListener('click', ()=>{
      if(!ORIG){ toast('Nothing to reset', 'err'); return; }
      RAW = JSON.parse(JSON.stringify(ORIG));
      undoStack.length = 0; document.getElementById('undoBtn').disabled = true;
      persistLocal(); requestLayout(); toast('Reset to original');
    });

    // Data inputs
    const fileInput = document.getElementById('fileInput');
    const loadBtn = document.getElementById('loadBtn');
    const renderBtn = document.getElementById('renderBtn');
    const sampleBtn = document.getElementById('sampleBtn');
    const jsonInput = document.getElementById('jsonInput');
    const rootId = document.getElementById('rootId');
    const searchBox = document.getElementById('searchBox');
    const searchBtn = document.getElementById('searchBtn');
    const searchInfo = document.getElementById('searchInfo');

    loadBtn.addEventListener('click', async ()=>{
      const f = fileInput.files?.[0]; if(!f){ alert('Pick a JSON file'); return; }
      const text = await f.text();
      jsonInput.value = text; // keep textarea in sync
      renderBtn.click();
    });

    renderBtn.addEventListener('click', ()=>{
      try{
        const data = JSON.parse(jsonInput.value || '[]');
        RAW = Array.isArray(data) ? data : [];
        RAW.forEach(r=>{ r.collapsed=false; });
        if(!ORIG) ORIG = JSON.parse(JSON.stringify(RAW));
        const rid = (rootId.value||'').trim();
        state.rootId = rid || null;
        if (rid && !RAW.some(r => String(r.id) === rid)) {
          toast('Root ID not found. Rendering full org instead.', 'err');
          state.rootId = null;
        }
        persistLocal(); requestLayout(); toast('Rendered data');
      }catch(e){ alert('Invalid JSON: ' + e.message); }
    });

    sampleBtn.addEventListener('click', ()=>{
      const sample = [];
      sample.push({id:'ceo', displayName:'CEO', jobTitle:'Chief Executive Officer', department:'Exec', managerId:null, reports:['vp1','vp2','vp3']});
      for(let i=1;i<=3;i++){
        const vp = `vp${i}`;
        sample.push({id:vp, displayName:`VP ${i}`, jobTitle:'Vice President', department:'Dept '+i, managerId:'ceo', reports:[`m${i}a`,`m${i}b`,`m${i}c`]});
        ['a','b','c'].forEach((s)=>{
          const mid = `m${i}${s}`;
          sample.push({id:mid, displayName:`Mgr ${i}${s.toUpperCase()}`, jobTitle:'Manager', department:'Ops', managerId:vp, reports:[`ic${i}${s}1`,`ic${i}${s}2`,`ic${i}${s}3`,`ic${i}${s}4`]});
          for(let k=1;k<=4;k++){
            sample.push({id:`ic${i}${s}${k}`, displayName:`IC ${i}${s}${k}`, jobTitle:'Engineer', department:'IMSD', managerId:mid});
          }
        });
      }
      jsonInput.value = JSON.stringify(sample, null, 2);
      rootId.value = '';
      renderBtn.click();
    });

    // Search
    searchBtn.addEventListener('click', ()=>{
      const q = (searchBox.value||'').toLowerCase().trim();
      if(!q){ searchInfo.textContent=''; return; }
      let bestId=null, bestScore=-1;
      for(const [id, m] of Object.entries(META)){
        const name=(m[0]||'').toLowerCase(), title=(m[1]||'').toLowerCase();
        let score = 0;
        if(name.includes(q)) score+=2;
        if(title.includes(q)) score+=1;
        if(id.toLowerCase().includes(q)) score+=1;
        if(score>bestScore){ bestScore=score; bestId=id; }
      }
      if(!bestId){ searchInfo.textContent='No match.'; return; }
      const xy = getCoord(bestId); if(!xy){ searchInfo.textContent='Found, not laid out.'; return; }
      const [x,y] = xy;
      const centerX = wrap.clientWidth/2, centerY = wrap.clientHeight/2;
      state.offsetX = centerX - (x + state.nodeW/2)*state.scale;
      state.offsetY = centerY - (y + state.nodeH/2)*state.scale;
      searchInfo.textContent = `Centered: ${META[bestId][0]} (${bestId})`;
      pulse(bestId); draw();
    });

    // LocalStorage
    function persistLocal(){
      try {
        localStorage.setItem('orgchart_raw', JSON.stringify(RAW));
        if (ORIG && !localStorage.getItem('orgchart_orig')) localStorage.setItem('orgchart_orig', JSON.stringify(ORIG));
      } catch {}
    }
    (function bootFromLocal(){
      try {
        const raw = localStorage.getItem('orgchart_raw');
        const orig = localStorage.getItem('orgchart_orig');
        if (raw) RAW = JSON.parse(raw);
        if (orig) ORIG = JSON.parse(orig);
        if (RAW && RAW.length) {
          RAW.forEach(r=>{ if(typeof r.collapsed==='undefined') r.collapsed=false; });
          requestLayout(); toast('Loaded from LocalStorage');
          jsonInput.value = JSON.stringify(RAW, null, 2);
        }
      } catch {}
    })();

    // Init
    window.addEventListener('resize', ()=>{ dprResize(); draw(); drawMinimap(); });
    dprResize();
  </script>
</body>
</html>
